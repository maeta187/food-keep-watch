# テスト方針

- 単体テストは `vitest` を使用し、ロジック寄りの関数や軽量なヘルパーからカバレッジを拡げる。
- 実行コマンドは以下を使用する。
  - `bun run test`: 一度だけ全テストを実行する。
  - `bun run test:watch`: ファイル変更を監視しながらテストを実行する。
  - `bun run test:coverage`: カバレッジ取得用のショートカットコマンド。
- カバレッジレポートを取得する場合は次の手順に従う。
  1. 依存関係に `@vitest/coverage-v8` が含まれているため、初回は `bun install` を実行してプラグインを取得する。
  2. `bun run test:coverage`（または `bunx vitest run --coverage`）を利用してテストとカバレッジ計測を同時に実行する。
  3. 標準出力には `text` レポート（ファイル単位の詳細）と `text-summary` レポート（総合値のみ）が表示される。
  4. `coverage/` ディレクトリには `lcov.info` と HTML レポートが出力される。`coverage/index.html` を開くとブラウザで詳細を確認できる。
- 追加したファイルが TypeScript の型チェックを通るよう `vitest/globals` を `tsconfig.json` に登録済み。

## ネイティブ依存に関する注意

- React Native 固有の UI やネイティブモジュールは JSDOM では再現できないため、ロジックを関数へ切り出しテスト可能な形に保つ。
- ネイティブモジュールを使う場合はモック化が必要。Expo のモジュールは `expo-mock-generator` など既存のモックを検討する。
- 画面操作の検証は e2e（Detox 等）や実機検証に委ね、ユニットテストでは副作用を持つロジックの境界に焦点を当てる。

## 今後の拡張のヒント

- 画面コンポーネントをテストする場合は `@testing-library/react-native` の導入を検討し、ネイティブモジュールのモック戦略を文書化する。
- CI でのテスト実行を想定し、将来的にはカバレッジレポートの閾値を設定する。
- テスト作成時は `.test.ts` を元コードに隣接配置し、必要に応じてモジュールごとの `__tests__` ディレクトリを使用する。
